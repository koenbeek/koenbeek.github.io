<!DOCTYPE html>
<html lang=”en”>
<!-- todo: basic sanity testing on range input & user feedback when wrong -->
<!-- todo: handle ranges outside of number of available keys better -> key = "" iso "undefined" -->

<head>
    <title>Sort Lines</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/main.css">
</head>

<body>
    <h1>Sort Lines</h1>

    <label for="key">Key RegExp:&nbsp;</label><input type="text" id="key" size=50>ex.: keyvalue:[A-Z0-9]{16}<br>
    <label for="sep">Seperator RegExp:&nbsp;</label><input type="text" id="sep" size=50>ex.: [,;]<br>
    <label for="range">Key Range:&nbsp;</label><input type="text" id="range" size=50>ex.: 4,5-7,1<br>
    <input type="checkbox" id="inverse">Inverse order<br>
    <input type="checkbox" id="ic">Ignore case<br>
    <input type="checkbox" id="unique">Unique lines only

    <h2>Input</h2>
    <textarea id="intext" rows="10" cols="100"></textarea><br>

    <h2>Output <button onclick="toCP()">Copy to Clipboard</button></h2>
    <textarea id="outtext" rows="10" cols="100" readonly></textarea><br>
</body>
<script type="module">
    import { gE, gV, gC, toCP, doSetup, sErr, sOK } from './js/lib.js';

    function sort() {
        var lines = [];
        var key = gV("key");
        var sep = gV("sep");
        var range = gV("range");
        var reopt = gC("ic") ? "igd" : "gd";
        var simple = (key == "" && sep == "")

        if (key != "" && sep != "") { sErr(["key", "sep"]); return; }
        sOK(["key", "sep"])
        var re;
        if (key != "") { try { re = new RegExp(key, reopt); } catch (e) { sErr("key"); return; }; };
        if (sep != "") { try { re = new RegExp(sep, reopt); } catch (e) { sErr("sep"); return; }; };

        var alllines = gV("intext").split('\n');
        if (gC("unique")) { alllines = [... new Set(alllines)] }
        alllines.map(line => {
            var allkeys = [];
            var linekey = "";
            if (key != "") { allkeys = line.match(re) || []; };
            if (sep != "") {
                var previd = 0;
                while ((match = re.exec(line)) != null) {
                    allkeys.push(line.substr(previd, match.indices[0][0] - previd))
                    previd = match.indices[0][1];
                }
                allkeys.push(line.substr(previd, line.length + 1 - previd))
            }
            if (key == "" && sep == "") { linekey = gC("ic") ? line.toUpperCase() : line };

            range = range.replace(/[^0-9,-]/g, '');
            linekey = "";
            if (range == "") {
                if (!simple) {
                    linekey = allkeys.join('');
                    if (gC("ic")) { linekey = linekey.toUpperCase() }
                }
            } else {
                range.split(",").forEach(r => {
                    var dashpos = r.indexOf("-");
                    if (dashpos == -1) {
                        end = start = parseInt(r);
                    } else {
                        start = parseInt(r.substr(0, dashpos));
                        end = parseInt(r.substr(dashpos + 1));
                    }
                    for (let i = start; i <= end; i++) { linekey += allkeys[i - 1]; }
                })
            }
            lines.push({ l: line, k: linekey })
        });

        gE("outtext").value = lines.sort(function (a, b) {
            var x = a.k; var y = b.k;
            if (gC("inverse")) { [x, y] = [y, x] };
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        }).map(l => l.l).join("\n");
    }
    doSetup(sort);
</script>

</html>